{"author":{"id":"MDQ6VXNlcjMyNTI3Mzc3","is_bot":false,"login":"realDGK","name":"realDGK"},"body":"Installing Goose from the source.  \n\nThe text_editor tool within the developer extension consistently fails with a \"Tool not found\" error, even when the tool is correctly invoked.  After extensive debugging, I identified that the tool's handler functions were incorrectly returning a Vec<Content> directly, instead of a properly formatted response object that includes the tool's name. This caused the mcp-client to reject the response.\n\nSteps to Reproduce:\n\n1. Set up a Goose AI environment using Docker Compose, as described in the documentation.\n\n2. Use  the Docker service that runs the Goose AI core logic and the mcp-server (the service built from the goose-mcp crate).\"\n\n3. Enable the developer extension.\n\n4. Attempt to use the text_editor tool with any command (e.g., create file /tmp/test.txt, then enter \"hello\" when prompted).\n\n5. The error \"Tool not found: \"\" for request...\" will appear.\n\nRoot Cause:\n\nThe text_editor_write, text_editor_view, text_editor_replace, and text_editor_undo functions in goose-mcp/src/developer/mod.rs were returning Result<Vec<Content>, ToolError>.  The mcp-client expects a response object (likely a ToolResult struct, though I didn't find its precise definition in the readily available code) that includes a name field indicating the originating tool.  Because this name field was missing, the client interpreted the response as coming from an unknown tool.\n\nAffected Files and Functions:\n\ngoose-mcp/src/developer/mod.rs\ntext_editor_write\ntext_editor_view\ntext_editor_replace\ntext_editor_undo\ntext_editor\ncall_tool\nTemporary Fix:\n\nImplemented a temporary fix by:\nCreating a ToolResult struct:  defined the following struct in goose-mcp/src/developer/mod.rs:\n\nRust\n\n#[derive(Debug)]\nstruct ToolResult {\n    name: String,\n    status: String,\n    value: Vec<Content>,\n}\n\nModifying the Handler Functions: changed the return type of text_editor_write, text_editor_view, text_editor_replace, text_editor_undo and text_editor to Result<ToolResult, ToolError>.  \n\nThen wrapped the Vec<Content> in an instance of this ToolResult struct, setting the name field to \"developer__text_editor\" and the status field to \"success\":\n\nRust\n\n// Example from text_editor_write:\nasync fn text_editor_write(\n    &self,\n    path: &PathBuf,\n    file_text: &str,\n) -> Result<ToolResult, ToolError> {\n    // ... (rest of the function logic) ...\n\n    Ok(ToolResult {\n        name: \"developer__text_editor\".to_string(),\n        status: \"success\".to_string(),\n        value: content_vec,\n    })\n}\n\nDid this for all of text_editor_write, text_editor_view, text_editor_replace, and text_editor_undo.\nand did similar changes for text_editor.\n\nModifying the call function updated the call_tool function to account for the change in return value from the text_editor tool:\n\nRust\n\n    fn call_tool(\n        &self,\n        tool_name: &str,\n        arguments: Value,\n    ) -> Pin<Box<dyn Future<Output = Result<Vec<Content>, ToolError>> + Send + 'static>> {\n        let this = self.clone();\n        let tool_name = tool_name.to_string();\n        Box::pin(async move {\n            match tool_name.as_str() {\n                \"shell\" => this.bash(arguments).await,\n                \"text_editor\" => {\n                    let result: ToolResult = this.text_editor(arguments).await?;\n                    Ok(result.value)\n                },\n                \"list_windows\" => this.list_windows(arguments).await,\n                \"screen_capture\" => this.screen_capture(arguments).await,\n                \"image_processor\" => this.image_processor(arguments).await,\n                _ => Err(ToolError::NotFound(format!(\"Tool {} not found\", tool_name))),\n            }\n        })\n    }\n\n\nEnvironment:\n\nDocker Compose setup (using the Goose AI provided configuration).\nthe Docker service that runs the Goose AI core logic and the mcp-server (the service built from the goose-mcp crate).\" service.\n\nWSL 2 (Windows Subsystem for Linux) - though this is likely not directly relevant to the bug itself, it did affect file permissions initially, which was resolved with umask 0000.\n\nAdditional Notes:\n\nThis is a temporary fix. The correct solution would involve using the intended ToolResult type (or equivalent) from the mcp crates, if one exists.\n\nI was unable to find the exact definition of the expected response structure in the code i had access to.\nRecommend checking other tools in the developer extension for similar issues\n","comments":[{"id":"IC_kwDOMneZ986h1cPE","author":{"login":"lily-de"},"authorAssociation":"COLLABORATOR","body":"> I identified that the tool's handler functions were incorrectly returning a Vec directly, instead of a properly formatted response object that includes the tool's name. This caused the mcp-client to reject the response.\n\nthis is really great digging thank you! ","createdAt":"2025-03-11T17:22:30Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/block/goose/issues/1614#issuecomment-2715141060","viewerDidAuthor":false}],"createdAt":"2025-03-11T09:25:49Z","labels":[{"id":"LA_kwDOMneZ988AAAABtyYvtQ","name":"bug","description":"Something isn't working","color":"B2E3B4"}],"number":1614,"state":"OPEN","title":"Bug Report: text_editor Tool Returns \"Tool not found\" Error - Missing name in Response","url":"https://github.com/block/goose/issues/1614"}
